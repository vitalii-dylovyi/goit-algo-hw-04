# Аналіз ефективності алгоритмів сортування

## Вступ
У цьому звіті оцінюється продуктивність трьох алгоритмів сортування: **Merge Sort** (сортування злиттям), **Insertion Sort** (сортування вставками) та **Timsort**. Аналіз показує, що Timsort перевершує інші два алгоритми завдяки своїй гібридній природі, яка поєднує переваги сортування злиттям і сортування вставками. Цей алгоритм є дуже ефективним для обробки реальних наборів даних, що робить його стандартним вибором у Python для операцій сортування. Аналіз базується на емпіричних тестах із використанням різних типів даних і розмірів наборів. Мета полягає в тому, щоб продемонструвати відносну ефективність цих алгоритмів, зокрема чому Timsort є найкращим вибором у більшості випадків.

## Огляд алгоритмів
### Merge Sort (Сортування злиттям)

- **Типові випадки використання**: Merge Sort особливо корисний для сортування великих наборів даних, де важлива стабільність (збереження порядку рівних елементів). Також цей алгоритм добре підходить для зовнішнього сортування (наприклад, сортування даних, що не вміщуються в пам'ять), завдяки передбачуваній складності O(n log n).
- **Складність часу виконання**:
  - Найкращий випадок: O(n log n)
  - Найгірший випадок: O(n log n)
- **Опис**: Алгоритм "розділяй і володарюй", який розбиває масив на частини, сортує кожну частину рекурсивно, а потім зливає їх.

### Insertion Sort (Сортування вставками)

- **Типові випадки використання**: Insertion Sort є особливо ефективним для малих наборів даних або майже відсортованих даних, таких як:
  1. Сортування невеликих частин даних (наприклад, малих масивів у гібридних алгоритмах, як Timsort).
  2. Додавання невеликої кількості елементів до вже відсортованого списку.
  3. Сценарії, де простота та мінімальні накладні витрати важливіші за продуктивність.

- **Складність часу виконання**:
  - Найкращий випадок: O(n) (для вже відсортованих масивів)
  - Найгірший випадок: O(n²)
- **Опис**: Простий алгоритм, який формує відсортований список по одному елементу, вставляючи їх у правильну позицію.

### Timsort
- **Складність часу виконання**:
  - Найкращий випадок: O(n)
  - Найгірший випадок: O(n log n)
- **Опис**: Гібридний алгоритм сортування, який поєднує Merge Sort і Insertion Sort. Він оптимізує продуктивність, використовуючи вже відсортовані фрагменти даних. Timsort є стандартним алгоритмом сортування в Python, оскільки ефективно балансує між продуктивністю та складністю. Завдяки використанню попередньо відсортованих сегментів ("runs"), він мінімізує зайві порівняння та переміщення, що робить його надзвичайно ефективним для реальних наборів даних. Стабільність і адаптивність до різних шаблонів у даних також сприяють його популярності.

## Налаштування експерименту
- **Набори даних**: Було протестовано три типи наборів даних:
  1. Випадкові цілі числа.
  2. Вже відсортовані масиви.
  3. Масиви, відсортовані у зворотному порядку.
- **Розміри**: Використовувалися масиви розміром 100, 1,000 і 10,000 елементів.
- **Інструмент вимірювання**: Модуль Python `timeit` використовувався для вимірювання часу виконання.

## Результати

Основні висновки з аналізу наведені нижче:
- **Timsort** перевершив як Merge Sort, так і Insertion Sort для всіх типів даних і розмірів масивів, особливо виділяючись на частково відсортованих даних.
- **Merge Sort** демонстрував стабільну продуктивність незалежно від типу набору даних, але був повільнішим за Timsort на малих наборах.
- **Insertion Sort** був ефективним для невеликих або майже відсортованих наборів даних, але ставав непридатним для великих наборів через квадратичну складність часу виконання.

Результати експериментів підсумовані нижче:

| Розмір  | Тип       | Алгоритм         | Час (с)         |
|---------|-----------|------------------|-----------------|
| 100     | Випадковий| Merge Sort       | Швидко          |
| 100     | Випадковий| Insertion Sort   | Швидко (але повільніше)|
| 100     | Зворотний | Timsort          | Дуже швидко     |

